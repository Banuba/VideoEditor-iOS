// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios15.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name VideoEditor
import AVFoundation
import AVKit
import BanubaLicenseServicingSDK
import BanubaUtilities
import CoreGraphics
import CoreMedia
import CoreVideo
import DeveloperToolsSupport
import Foundation
import MetalKit
import QuartzCore
import Swift
import SwiftUI
import UIKit
@_exported import VideoEditor
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public protocol VideoEditorImageAssetProtocol : AnyObject {
  var duration: Foundation.TimeInterval { get }
  var image: CoreGraphics.CGImage? { get }
  var shouldUseImageEffect: Swift.Bool { get }
  func getOrPreloadImage() -> CoreGraphics.CGImage?
  func unloadImage()
}
@_hasMissingDesignatedInitializers public class AudioMixer {
  public struct VolumeDefaults {
    public static let mutedVolume: Swift.Float
    public static let defaultVolume: Swift.Float
  }
  public func getAudioMix(for asset: AVFoundation.AVAsset?) -> AVFoundation.AVAudioMix?
  public func resetTrackVolumeToDefault(trackId: CoreMedia.CMPersistentTrackID)
  public func setVolume(_ volume: Swift.Float, forTrackId trackId: CoreMedia.CMPersistentTrackID)
  public func volume(forTrackId trackId: CoreMedia.CMPersistentTrackID) -> Swift.Float
  public func isVolumeDefault(forTrackId trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  public func mutedMusicMix(asset: AVFoundation.AVAsset?) -> AVFoundation.AVAudioMix?
  public func mutedAudioMix(asset: AVFoundation.AVAsset?) -> AVFoundation.AVAudioMix?
  @objc deinit
}
extension VideoEditor.CompositionRenderering {
  public var className: Swift.String {
    get
  }
  public static var className: Swift.String {
    get
  }
  public func cleanUpResources()
}
public protocol CompositionRenderering : AnyObject {
  init()
  func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, effect: any VideoEditor.EditorCompositionEffectProtocol, additionalParameters: [Swift.String : Any]?)
  func cleanUpResources()
}
@_hasMissingDesignatedInitializers public class EditorEffectsFilter {
  public static func filterAddedEffects(effects: [any VideoEditor.EditorCompositionEditableEffectProtocol]) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
public struct CustomSDKVideoCompositionConfig {
  public static let renderingQueueName: Swift.String
}
public enum EditorEffectType : Swift.Int {
  case crop
  case transition
  case blur
  case gif
  case text
  case time
  case color
  case visual
  case mask
  case transform
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol VideoEditorTrackServicing {
  var preferredTrackId: CoreMedia.CMPersistentTrackID { get }
  func hasVideoAudio() -> Swift.Bool
  func isAudioTrackVolumeChanged() -> Swift.Bool
  func videoVolume() -> Swift.Float
  func setVideoVolume(_ volume: Swift.Float)
  func setVideoVolume(_ volume: Swift.Float, to player: any BanubaUtilities.VideoEditorPlayable)
  func hasPiPAudio() -> Swift.Bool
  func isPiPAudioTrackVolumeChanged() -> Swift.Bool
  func getPiPAudioVolume() -> Swift.Float
  func setPiPAudioVolume(_ volume: Swift.Float, to player: any BanubaUtilities.VideoEditorPlayable)
  func setPiPAudioVolume(_ volume: Swift.Float)
  func addMusicTrack(didSelectFile url: Foundation.URL, coverURL: Foundation.URL?, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID, preferredTrackID: CoreMedia.CMPersistentTrackID?, start: CoreMedia.CMTime, duration: CoreMedia.CMTime?, trimmedStart: Foundation.TimeInterval?) -> (id: CoreMedia.CMPersistentTrackID, asset: AVFoundation.AVURLAsset, timeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, compositionStart: CoreMedia.CMTime, avAssetTrack: AVFoundation.AVAssetTrack)?
  func changeMusicTrackPosition(currentTime: Swift.Double, durationInSeconds: Swift.Double, compositionTimeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, assetTrack: AVFoundation.AVAssetTrack, audioTrackId: CoreMedia.CMPersistentTrackID, audioServiceItem: BanubaUtilities.AudioServiceItem) -> CoreMedia.CMTimeRange?
  func getTrackVolume(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Float
  func setTrack(trackId: CoreMedia.CMPersistentTrackID, volume: Swift.Float, to player: any BanubaUtilities.VideoEditorPlayable)
  func removeTrack(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  func removeAllMusicTracks()
}
public protocol WatermarkApplicatorServicing : AnyObject {
  func adjustWatermarkEffect(configuration: VideoEditor.WatermarkConfiguration, videoSize: CoreFoundation.CGSize) -> VideoEditor.VideoEditorFilterModel
}
public protocol VideoEditorServicing : VideoEditor.EffectsManagement, VideoEditor.VideoEditorTrackServicing {
  var asset: AVFoundation.AVAsset? { get }
  var videoAsset: VideoEditor.VideoEditorAsset? { get set }
  var exportFrameDuration: CoreMedia.CMTime { get set }
  var videoSize: CoreFoundation.CGSize { get set }
  var audioMixer: VideoEditor.AudioMixer? { get set }
  func getEditorEffects(type: VideoEditor.EditorEffectType) -> [VideoEditor.VideoEditorFilterModel]
  func setCurrentAsset(_ asset: VideoEditor.VideoEditorAsset?)
  func setEditorEffects(_ effects: [VideoEditor.VideoEditorFilterModel])
  func getImageGenerator() -> AVFoundation.AVAssetImageGenerator?
  func videoPartsCount() -> Swift.Int
  func getLicenseState(completion: @escaping ((Swift.Bool) -> Swift.Void))
  init?(token: Swift.String)
  init(license: BanubaLicenseServicingSDK.License)
}
final public class VideoEditorService {
  final public func getVideoPlayerItem(forExternalAsset asset: AVFoundation.AVAsset?) -> AVFoundation.AVPlayerItem?
  final public func getMusicPlayerItem(forExternalAsset asset: AVFoundation.AVAsset?) -> AVFoundation.AVPlayerItem?
  final public var videoAsset: VideoEditor.VideoEditorAsset? {
    get
    set
  }
  final public var asset: AVFoundation.AVAsset? {
    get
  }
  final public var videoSize: CoreFoundation.CGSize
  final public var exportFrameDuration: CoreMedia.CMTime
  final public var audioMixer: VideoEditor.AudioMixer?
  final public var effects: VideoEditor.AppliedEffectsStack {
    get
  }
  final public var autoCutEffects: VideoEditor.AutoCutEffectsStack {
    get
  }
  final public let license: BanubaLicenseServicingSDK.License
  convenience public init?(token: Swift.String)
  public init(license: BanubaLicenseServicingSDK.License)
  @objc deinit
  final public func createExportComposition(asset: AVFoundation.AVAsset, dataSource: (any VideoEditor.SDKVideoCompositionInstructionDataSource)?, renderSize: CoreFoundation.CGSize) -> AVFoundation.AVVideoComposition?
}
extension VideoEditor.VideoEditorService : VideoEditor.EffectsManagement {
  final public func changeEffectTimeRange(with uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  final public func applyEffect(effectModel: VideoEditor.VideoEditorFilterModel, uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime, removeSameType: Swift.Bool, isAutoCutEffect: Swift.Bool)
  final public func getSpeed(at time: CoreMedia.CMTime) -> Swift.Float
  @discardableResult
  final public func undoEffect(uuid: Swift.String) -> (any VideoEditor.EditorCompositionEffectProtocol)?
  @discardableResult
  final public func undoLast(type: VideoEditor.EditorEffectType) -> (any VideoEditor.EditorCompositionEffectProtocol)?
  final public func undoAll(type: VideoEditor.EditorEffectType)
  final public func undoAll(except type: VideoEditor.EditorEffectType)
  final public func undoAll()
  final public func startCurrentEffect(effectModel: VideoEditor.VideoEditorFilterModel, at: CoreMedia.CMTime)
  final public func endCurrentEffect(at: CoreMedia.CMTime)
  final public func getCurrentAppliedEffects(type: VideoEditor.EditorEffectType) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  final public func getStoredEffects(type: VideoEditor.EditorEffectType) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  final public func getCurrentAppliedEffects() -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  final public func storeStack()
  final public func restoreStack()
  final public func hasChangesInAppliedEffects() -> Swift.Bool
  final public func hasAutoCutEffects() -> Swift.Bool
  final public func undoAutoCutEffects()
}
extension VideoEditor.VideoEditorService : VideoEditor.SDKVideoCompositionInstructionDataSource {
  final public func getEffects(at time: CoreMedia.CMTime) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  final public func getEffectsBefore(time: CoreMedia.CMTime) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
}
extension VideoEditor.VideoEditorService : VideoEditor.VideoEditorServicing {
  final public func getImageGenerator() -> AVFoundation.AVAssetImageGenerator?
  final public func reattachMusicTracks(_ mutableAsset: AVFoundation.AVMutableComposition)
  final public func getEditorEffects(type: VideoEditor.EditorEffectType) -> [VideoEditor.VideoEditorFilterModel]
  final public func setCurrentAsset(_ asset: VideoEditor.VideoEditorAsset?)
  final public func setEditorEffects(_ effects: [VideoEditor.VideoEditorFilterModel])
  final public func videoPartsCount() -> Swift.Int
  final public func getLicenseState(completion: @escaping ((Swift.Bool) -> Swift.Void))
}
extension VideoEditor.VideoEditorService : VideoEditor.VideoEditorTrackServicing {
  final public var preferredTrackId: CoreMedia.CMPersistentTrackID {
    get
  }
  final public func hasVideoAudio() -> Swift.Bool
  final public func isAudioTrackVolumeChanged() -> Swift.Bool
  final public func videoVolume() -> Swift.Float
  final public func setVideoVolume(_ volume: Swift.Float)
  final public func setVideoVolume(_ volume: Swift.Float, to player: any BanubaUtilities.VideoEditorPlayable)
  final public func hasPiPAudio() -> Swift.Bool
  final public func isPiPAudioTrackVolumeChanged() -> Swift.Bool
  final public func getPiPAudioVolume() -> Swift.Float
  final public func setPiPAudioVolume(_ volume: Swift.Float, to player: any BanubaUtilities.VideoEditorPlayable)
  final public func setPiPAudioVolume(_ volume: Swift.Float)
  final public func hasPiPAudioTrack() -> Swift.Bool
  final public func changeMusicTrackPosition(currentTime: Swift.Double, durationInSeconds: Swift.Double, compositionTimeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, assetTrack: AVFoundation.AVAssetTrack, audioTrackId: CoreMedia.CMPersistentTrackID, audioServiceItem: BanubaUtilities.AudioServiceItem) -> CoreMedia.CMTimeRange?
  final public func addMusicTrack(didSelectFile url: Foundation.URL, coverURL: Foundation.URL?, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID, preferredTrackID: CoreMedia.CMPersistentTrackID?, start: CoreMedia.CMTime, duration: CoreMedia.CMTime?, trimmedStart: Foundation.TimeInterval?) -> (id: CoreMedia.CMPersistentTrackID, asset: AVFoundation.AVURLAsset, timeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, compositionStart: CoreMedia.CMTime, avAssetTrack: AVFoundation.AVAssetTrack)?
  final public func getTrackVolume(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Float
  final public func setTrack(trackId: CoreMedia.CMPersistentTrackID, volume: Swift.Float, to player: any BanubaUtilities.VideoEditorPlayable)
  final public func removeTrack(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  final public func removeAllMusicTracks()
}
public struct RevokedTokenError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var localizedDescription: Swift.String {
    get
  }
  public init()
}
public class VideoTrimData {
  public var start: CoreMedia.CMTime {
    get
  }
  public var end: CoreMedia.CMTime {
    get
  }
  public var duration: CoreMedia.CMTime {
    get
  }
  public init(start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  @objc deinit
}
public protocol ExportScalable {
  func exportScaled(outputUrl: Foundation.URL, quality: Swift.String, trimData: VideoEditor.VideoTrimData?, completion: (((any Swift.Error)?) -> Swift.Void)?)
}
public protocol AssetEditable {
  func addTracks(_ tracks: [VideoEditor.VideoEditorAssetTrackInfo], atIndex index: Swift.Int)
  func removeTrack(at index: Swift.Int)
  func removeTrack(_ track: VideoEditor.VideoEditorAssetTrackInfo)
  func moveTrack(fromIndex: Swift.Int, toIndex: Swift.Int)
  func reorderTracks(withTracks reorderedTracks: [VideoEditor.VideoEditorAssetTrackInfo])
}
public struct VideoEditorAssetMusicTrack {
  public let track: BanubaUtilities.MediaTrack
  public let trackId: CoreMedia.CMPersistentTrackID
}
public class VideoEditorAsset {
  public var composition: AVFoundation.AVMutableComposition!
  public var instructions: [any AVFoundation.AVVideoCompositionInstructionProtocol]? {
    get
  }
  public var errors: [any Swift.Error] {
    get
  }
  public var tracksInfo: [VideoEditor.VideoEditorAssetTrackInfo] {
    get
  }
  final public let videoResolutionConfiguration: BanubaUtilities.VideoResolutionConfiguration
  public var videoResolutionCurrentSize: CoreFoundation.CGSize?
  public var fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat>
  public var musicTracks: [VideoEditor.VideoEditorAssetMusicTrack] {
    get
  }
  public init(tracks: [VideoEditor.VideoEditorAssetTrackInfo], isDebugModeOn: Swift.Bool = false, fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat> = CGFloat(0)...CGFloat(0), videoResolutionConfiguration: BanubaUtilities.VideoResolutionConfiguration)
  convenience public init(sequence: VideoEditor.VideoSequence, isGalleryAssets: Swift.Bool, isSlideShow: Swift.Bool, isDebugModeOn: Swift.Bool = false, fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat> = CGFloat(0)...CGFloat(0), videoResolutionConfiguration: BanubaUtilities.VideoResolutionConfiguration)
  public func reloadComposition()
  public func loadNonExistingThumbnails(completion: (() -> ())?)
  public func getPartIndex(at time: CoreMedia.CMTime) -> Swift.Int?
  @objc deinit
}
extension VideoEditor.VideoEditorAsset {
  public func changeMusicTrackPosition(_ musicTrack: BanubaUtilities.MediaTrack) -> Swift.Bool
  public func hasMusicTrack(with trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  @discardableResult
  public func addMusicTrack(_ musicTrack: BanubaUtilities.MediaTrack) -> (compositionTrack: AVFoundation.AVMutableCompositionTrack, assetTrack: AVFoundation.AVAssetTrack)?
  @discardableResult
  public func removeMusic(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  public func removeAllMusic()
}
extension VideoEditor.VideoEditorAsset : VideoEditor.ExportScalable {
  public func exportScaled(outputUrl: Foundation.URL, quality: Swift.String, trimData: VideoEditor.VideoTrimData?, completion: (((any Swift.Error)?) -> Swift.Void)?)
}
extension VideoEditor.VideoEditorAsset : VideoEditor.AssetEditable {
  public func addTracks(_ tracks: [VideoEditor.VideoEditorAssetTrackInfo], atIndex index: Swift.Int)
  public func removeTrack(at index: Swift.Int)
  public func removeTrack(_ track: VideoEditor.VideoEditorAssetTrackInfo)
  public func moveTrack(fromIndex: Swift.Int, toIndex: Swift.Int)
  public func reorderTracks(withTracks reorderedTracks: [VideoEditor.VideoEditorAssetTrackInfo])
}
@_hasMissingDesignatedInitializers public class MetalHelperHolder {
  public static let shared: VideoEditor.MetalHelperHolder
  final public let metalHelper: VideoEditor.MetalHelper
  @objc deinit
}
@_hasMissingDesignatedInitializers public class VideoAspectRatioCalculator {
  public static func calculateVideoAspectRatio(withVideoSize videoSize: CoreFoundation.CGSize) -> Swift.Double
  public static func adjustVideoSize(_ videoSize: CoreFoundation.CGSize, withAspectRatio aspectRatio: Swift.Double) -> CoreFoundation.CGSize
  @objc deinit
}
public enum ContentLocationType {
  case remote
  case local
  public static func == (a: VideoEditor.ContentLocationType, b: VideoEditor.ContentLocationType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class VideoEditorFilterModel {
  public var id: Swift.UInt {
    get
  }
  public var tokenId: Swift.String {
    get
  }
  final public let filterType: VideoEditor.EditorEffectType
  final public let name: Swift.String
  final public let path: Swift.String
  final public let contentLocationType: VideoEditor.ContentLocationType
  public var preview: Foundation.URL?
  public var additionalParameters: [Swift.String : Any]?
  public var rendererInstance: (any VideoEditor.CompositionRenderering)? {
    get
  }
  convenience public init(name: Swift.String, type: VideoEditor.EditorEffectType, contentLocationType: VideoEditor.ContentLocationType = .local, renderer: (any VideoEditor.CompositionRenderering.Type)?, path: Swift.String = "", id: Swift.UInt, tokenId: Swift.String, rendererInstance: (any VideoEditor.CompositionRenderering)?, preview: Foundation.URL? = nil, additionalParameters: [Swift.String : Any]?)
  public init(name: Swift.String, type: VideoEditor.EditorEffectType, contentLocationType: VideoEditor.ContentLocationType = .local, renderer: (any VideoEditor.CompositionRenderering.Type)?, path: Swift.String = "", speed: VideoEditor.EffectSpeed = .normal, transition: BanubaUtilities.TransitionType = .normal, id: Swift.UInt, tokenId: Swift.String, rendererInstance: (any VideoEditor.CompositionRenderering)?, preview: Foundation.URL? = nil, additionalParameters: [Swift.String : Any]?)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AppliedEffectsStack : VideoEditor.EffectStack {
  public func getAllEffects(at time: CoreMedia.CMTime) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  public func getAllEffects() -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
public class VideoSequenceItem {
  @_hasMissingDesignatedInitializers public class VideoInfo {
    final public let duration: Foundation.TimeInterval
    final public let resolution: CoreFoundation.CGSize
    @objc deinit
  }
  final public let uuidString: Swift.String
  final public let url: Foundation.URL
  public var videoInfo: VideoEditor.VideoSequenceItem.VideoInfo {
    get
    set
  }
  final public let isGalleryAsset: Swift.Bool
  final public let isSlideShow: Swift.Bool
  final public let isPIP: Swift.Bool
  final public let isCopy: Swift.Bool
  public var rotation: VideoEditor.AssetRotation
  public var crop: VideoEditor.AssetCrop?
  public var cropFrame: CoreFoundation.CGRect?
  final public let preview: UIKit.UIImage?
  final public let originalAssetResolution: CoreFoundation.CGSize?
  public var previewUrl: Foundation.URL?
  public var speed: Swift.Double {
    get
  }
  public var name: Swift.String {
    get
  }
  public var transition: BanubaUtilities.TransitionType
  public init(uuidString: Swift.String, assetUrl url: Foundation.URL, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, isPIP: Swift.Bool, isCopy: Swift.Bool, rotation: VideoEditor.AssetRotation, crop: VideoEditor.AssetCrop?, cropFrame: CoreFoundation.CGRect?, preview: UIKit.UIImage?, previewUrl: Foundation.URL?, transition: BanubaUtilities.TransitionType, originalAssetResolution: CoreFoundation.CGSize?)
  public func tryReplaceVideo(at videoUrl: Foundation.URL) -> Swift.Bool
  @objc deinit
}
@objc public class VideoSequence : ObjectiveC.NSObject {
  final public let folderURL: Foundation.URL
  public var modificationDate: Foundation.Date {
    get
    set
  }
  public var preview: UIKit.UIImage?
  public var videos: [VideoEditor.VideoSequenceItem]
  public var sequenceId: Swift.String {
    get
  }
  public var durations: [Foundation.TimeInterval] {
    get
  }
  public var initialDurations: [Foundation.TimeInterval] {
    get
  }
  public var isGallerySequence: Swift.Bool {
    get
  }
  public var removedVideos: [VideoEditor.VideoSequenceItem] {
    get
  }
  required public init(folderURL: Foundation.URL)
  @objc deinit
}
extension VideoEditor.VideoSequence {
  public func remove()
  public func removeVideos()
  @discardableResult
  public func deleteVideo(_ video: VideoEditor.VideoSequenceItem) -> Swift.Bool
  @discardableResult
  public func deleteVideo(uuidString: Swift.String) -> Swift.Bool
  public var hasRemovedVideos: Swift.Bool {
    get
  }
  public func restoreRemovedVideos()
  @discardableResult
  public func removeVideo(_ video: VideoEditor.VideoSequenceItem) -> Swift.Bool
}
extension VideoEditor.VideoSequence {
  public static func generateName() -> Swift.String
}
extension VideoEditor.VideoSequence {
  @discardableResult
  public func addVideo(uuidString: Swift.String = UUID().uuidString, at url: Foundation.URL, speed: Swift.Double = 1.0, isGalleryAsset: Swift.Bool = false, isSlideShow: Swift.Bool, isPIP: Swift.Bool = false, isRemovedVideo: Swift.Bool = false, rotation: VideoEditor.AssetRotation = .none, crop: VideoEditor.AssetCrop? = nil, cropFrame: CoreFoundation.CGRect? = nil, preview: UIKit.UIImage? = nil, shouldMoveFile: Swift.Bool = true, shouldUseUniqName: Swift.Bool = true, transition: BanubaUtilities.TransitionType, originalAssetResolution: CoreFoundation.CGSize? = nil) -> VideoEditor.VideoSequenceItem?
  @discardableResult
  public func addVideoCopy(uuidString: Swift.String, at url: Foundation.URL, speed: Swift.Double = 1.0, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, isPIP: Swift.Bool, isRemoved: Swift.Bool = false, rotation: VideoEditor.AssetRotation = .none, crop: VideoEditor.AssetCrop?, cropFrame: CoreFoundation.CGRect?, preview: UIKit.UIImage? = nil, transition: BanubaUtilities.TransitionType, originalAssetResolution: CoreFoundation.CGSize? = nil) -> VideoEditor.VideoSequenceItem?
  public func didUpdateVideo(_ video: VideoEditor.VideoSequenceItem)
}
extension VideoEditor.VideoSequence {
  public typealias SequnceVideos = (originalVideos: [VideoEditor.VideoSequenceItem], videos: [VideoEditor.VideoSequenceItem])
  public func getVideoFileNames(in directory: Foundation.URL) -> VideoEditor.VideoSequence.SequnceVideos
}
extension VideoEditor.VideoSequence {
  public func totalDuration(isSpeedCountingEnabled: Swift.Bool = true) -> Foundation.TimeInterval
  public func getDurations(isSpeedCountingEnabled: Swift.Bool = true) -> [Foundation.TimeInterval]
}
extension VideoEditor.VideoSequence {
  public static func restore(folder: Foundation.URL) -> VideoEditor.VideoSequence
}
extension VideoEditor.VideoSequence {
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class VideoSpeedHelper {
  public static func generateFilename(with name: Swift.String, speed: Swift.Double) -> Swift.String
  public static func extractSpeed(from filename: Swift.String) -> Swift.Double
  public static func extractSpeed(from fileUrl: Foundation.URL) -> Swift.Double
  @objc deinit
}
@objc public class VideoImagesComposition : ObjectiveC.NSObject {
  public init(sequence: VideoEditor.VideoEditorImagesSequence, videoResolution: BanubaUtilities.VideoResolution)
  public func exportVideo(to file: Foundation.URL, quality: Swift.String, completion: (((any Swift.Error)?) -> Swift.Void)?)
  public func cancelExport()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class EffectStack {
  public func getAllEffects(at time: CoreMedia.CMTime, from: [any VideoEditor.EditorCompositionEditableEffectProtocol]) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
public protocol VideoImageEffectDrawable {
  func draw(imageTexture: any Metal.MTLTexture, in pixelBuffer: CoreVideo.CVPixelBuffer, sampleTime: Foundation.TimeInterval, startTime: Foundation.TimeInterval, endTime: Foundation.TimeInterval, imageSize: CoreFoundation.CGSize)
}
public struct VideoSequenceNameDuplacatesFinder {
  public let sequenceName: Swift.String
  public init(sequenceName: Swift.String)
  public func findDuplicates(inSequenceNames sequenceNames: [Swift.String]) -> [Swift.String]
  public func getIndex(fromName: Swift.String?) -> Swift.Int?
}
public protocol VideoEditorSDKServicing {
  var videoEditorService: VideoEditor.VideoEditorService { get }
}
public protocol AudioVideoEditorSDKServicing : VideoEditor.VideoEditorSDKServicing {
  var audioService: any BanubaUtilities.AudioServicing { get }
}
extension CoreMedia.CMTime {
  public func scaledTime(by scaleValue: Swift.Double) -> CoreMedia.CMTime
  public func unscaledTime(by scaleValue: Swift.Double) -> CoreMedia.CMTime
}
public protocol EffectsManagement : AnyObject {
  func getStoredEffects(type: VideoEditor.EditorEffectType) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  func getCurrentAppliedEffects(type: VideoEditor.EditorEffectType) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  func applyEffect(effectModel: VideoEditor.VideoEditorFilterModel, uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime, removeSameType: Swift.Bool, isAutoCutEffect: Swift.Bool)
  func startCurrentEffect(effectModel: VideoEditor.VideoEditorFilterModel, at: CoreMedia.CMTime)
  func endCurrentEffect(at: CoreMedia.CMTime)
  func undoEffect(uuid: Swift.String) -> (any VideoEditor.EditorCompositionEffectProtocol)?
  func undoLast(type: VideoEditor.EditorEffectType) -> (any VideoEditor.EditorCompositionEffectProtocol)?
  func undoAll(type: VideoEditor.EditorEffectType)
  func undoAll(except: VideoEditor.EditorEffectType)
  func undoAll()
  func getSpeed(at time: CoreMedia.CMTime) -> Swift.Float
  func changeEffectTimeRange(with uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  func hasChangesInAppliedEffects() -> Swift.Bool
  func storeStack()
  func restoreStack()
}
public class VideoEditorImagesSequence {
  @objc deinit
  public init(imageAssets: [any VideoEditor.VideoEditorImageAssetProtocol])
}
@_hasMissingDesignatedInitializers public class VideoEditorTrackRotationCalculator {
  public static func getTrackRotation(_ track: VideoEditor.VideoEditorAssetTrackInfo) -> VideoEditor.AssetRotation
  @objc deinit
}
public enum AssetCrop : Swift.UInt8, Swift.Codable {
  case custom
  case crop9x16
  case crop3x4
  case crop4x3
  case crop1x1
  case crop4x5
  public var value: CoreFoundation.CGFloat {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum AssetRotation : Swift.UInt8, Swift.Codable {
  case none
  case rotate90
  case rotate180
  case rotate270
  public init?(withAngle angle: CoreFoundation.CGFloat)
  public var angle: CoreFoundation.CGFloat {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension AVFoundation.AVAssetTrack {
  public func transform(with dstSize: CoreFoundation.CGSize) -> CoreFoundation.CGAffineTransform
  public func fillOrFitTransform(with dstSize: CoreFoundation.CGSize, fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat>, rotation: VideoEditor.AssetRotation) -> CoreFoundation.CGAffineTransform
  public func compositionTransformInstruction(transform: CoreFoundation.CGAffineTransform, start: CoreMedia.CMTime, duration: CoreMedia.CMTime, bgColor: CoreGraphics.CGColor? = nil) -> any AVFoundation.AVVideoCompositionInstructionProtocol
}
@_hasMissingDesignatedInitializers public class ExportScaledTimeline : VideoEditor.EffectStack {
  public var composition: AVFoundation.AVMutableComposition? {
    get
  }
  public init(with composition: AVFoundation.AVMutableComposition?, allowOverlappingVisualEffects: Swift.Bool = false)
  public func scaleAndArrange(with effects: [any VideoEditor.EditorCompositionEditableEffectProtocol])
  public func canBeIntersected(effectType: VideoEditor.EditorEffectType) -> Swift.Bool
  @objc deinit
}
extension VideoEditor.ExportScaledTimeline : VideoEditor.SDKVideoCompositionInstructionDataSource {
  public func getEffects(at time: CoreMedia.CMTime) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  public func getEffectsBefore(time: CoreMedia.CMTime) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
}
public class AverageSum {
  public init(name: Swift.String, skipFirstCount: Swift.Int, autoprint: Swift.Bool = true, autoprintInterval: Swift.UInt = 100)
  @objc deinit
}
@_inheritsConvenienceInitializers public class AverageTimeSum : VideoEditor.AverageSum {
  public func begin()
  public func end()
  override public init(name: Swift.String, skipFirstCount: Swift.Int, autoprint: Swift.Bool = super, autoprintInterval: Swift.UInt = super)
  @objc deinit
}
extension UIKit.UIImage {
  public static func orientation(byRotation rotation: VideoEditor.AssetRotation) -> UIKit.UIImage.Orientation
}
@_hasMissingDesignatedInitializers public class MetalVerticesAndUVData {
  public static let quadVertexData: [Swift.Float]
  public static func quadVertexData(scale: Swift.Float) -> [Swift.Float]
  public static let defaultTextureCoordinates: [Swift.Float]
  @objc deinit
}
public enum EffectSpeed : Swift.Float {
  case normal
  case slowmo
  case rapid
  public init?(rawValue: Swift.Float)
  public typealias RawValue = Swift.Float
  public var rawValue: Swift.Float {
    get
  }
}
@_hasMissingDesignatedInitializers public class EditorCompositionFactory {
  public static func createEditorEffect(start: CoreMedia.CMTime, end: CoreMedia.CMTime, model: VideoEditor.VideoEditorFilterModel, uuid: Swift.String, additionalParameters: [Swift.String : Any]?) -> any VideoEditor.EditorCompositionEditableEffectProtocol
  public static func createEditorEffect(start: CoreMedia.CMTime, end: CoreMedia.CMTime, type: VideoEditor.EditorEffectType, renderer: (any VideoEditor.CompositionRenderering.Type)?, path: Swift.String, speed: VideoEditor.EffectSpeed, transition: BanubaUtilities.TransitionType = .normal, uuid: Swift.String, id: Swift.UInt, tokenId: Swift.String, rendererInstance: (any VideoEditor.CompositionRenderering)?, additionalParameters: [Swift.String : Any]?) -> any VideoEditor.EditorCompositionEditableEffectProtocol
  public static func zeroTimeEffect() -> any VideoEditor.EditorCompositionEditableEffectProtocol
  @objc deinit
}
public protocol EditorCompositionEffectProtocol : AnyObject {
  var additionalParameters: [Swift.String : Any]? { get }
  var startTime: CoreMedia.CMTime { get }
  var endTime: CoreMedia.CMTime { get }
  var id: Swift.UInt { get }
  var tokenId: Swift.String { get set }
  var path: Swift.String { get }
}
public protocol EditorCompositionEditableEffectProtocol : Foundation.NSCopying, VideoEditor.EditorCompositionEffectProtocol {
  var startTime: CoreMedia.CMTime { get set }
  var endTime: CoreMedia.CMTime { get set }
  var filterType: VideoEditor.EditorEffectType { get }
  var speed: VideoEditor.EffectSpeed { get }
  var transitionType: BanubaUtilities.TransitionType { get }
  var uuid: Swift.String { get }
  var rendererClass: (any VideoEditor.CompositionRenderering.Type)? { get }
  var rendererInstance: (any VideoEditor.CompositionRenderering)? { get }
  var additionalParameters: [Swift.String : Any]? { get }
  func isInTime(_ time: CoreMedia.CMTime) -> Swift.Bool
  func isEqual(to: any VideoEditor.EditorCompositionEditableEffectProtocol) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class AutoCutEffectsStack {
  final public var isEmpty: Swift.Bool {
    get
  }
  final public func addEffect(_ effectModel: VideoEditor.VideoEditorFilterModel, uuid: Swift.String, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime)
  final public func getAllEffects(at time: CoreMedia.CMTime) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  final public func getAllEffects() -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
public struct VideoSequenceNameFormatter {
  public init()
  public func formattedNameFromDate(_ date: Foundation.Date) -> Swift.String
  public func formattedDraftSubtitleFromTime(_ time: Foundation.TimeInterval) -> Swift.String
}
final public class VideoEditorAssetTrackInfo : Swift.Hashable, Swift.Equatable, Swift.Codable {
  final public let uuidString: Swift.String
  final public var url: Foundation.URL {
    get
  }
  final public var fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat>
  final public let videoResolutionConfiguration: BanubaUtilities.VideoResolutionConfiguration
  final public var videoCurentSize: CoreFoundation.CGFloat?
  final public var thumbnail: UIKit.UIImage?
  final public var thumbnails: [UIKit.UIImage]
  final public var trimTimeRange: CoreMedia.CMTimeRange
  final public var rotation: VideoEditor.AssetRotation {
    get
    set
  }
  final public var speed: Swift.Double? {
    get
    set
  }
  final public var cropFrame: CoreFoundation.CGRect?
  final public var crop: VideoEditor.AssetCrop?
  final public var videoSize: CoreFoundation.CGSize {
    get
  }
  final public var videoName: Swift.String {
    get
  }
  final public var isGalleryAsset: Swift.Bool
  final public var isSlideShow: Swift.Bool
  final public var composition: AVFoundation.AVComposition! {
    get
  }
  final public var instructions: [any AVFoundation.AVVideoCompositionInstructionProtocol]? {
    get
  }
  final public var error: (any Swift.Error)? {
    get
  }
  final public var timeRange: CoreMedia.CMTimeRange {
    get
  }
  final public var urlAsset: AVFoundation.AVAsset {
    get
  }
  final public var timeRangeInGlobal: CoreMedia.CMTimeRange
  final public let originalAssetResolution: CoreFoundation.CGSize?
  final public var transitionEffectType: BanubaUtilities.TransitionType
  public init(uuidString: Swift.String, url: Foundation.URL, rotation: VideoEditor.AssetRotation, speed: Swift.Double?, thumbnail: UIKit.UIImage?, fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat>, videoResolutionConfiguration: BanubaUtilities.VideoResolutionConfiguration, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, transitionEffectType: BanubaUtilities.TransitionType, originalAssetResolution: CoreFoundation.CGSize?)
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case uuidString
    case url
    case rotation
    case thumbnail
    case fillAspectRatioRange
    case videoResolutionConfiguration
    case isGalleryAsset
    case isSlideShow
    case originalAssetResolution
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(from decoder: any Swift.Decoder) throws
  final public func encode(to encoder: any Swift.Encoder) throws
  final public func copy() -> VideoEditor.VideoEditorAssetTrackInfo
  final public func replaceAssetUrl(_ url: Foundation.URL)
  final public func rotate(clockwise: Swift.Bool)
  final public func getTimeRangeWithSpeedExtension() -> CoreMedia.CMTimeRange
  final public func updatePreview()
  final public func extractSpeed() -> Swift.Double
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
extension VideoEditor.VideoEditorAssetTrackInfo {
  public static func == (lhs: VideoEditor.VideoEditorAssetTrackInfo, rhs: VideoEditor.VideoEditorAssetTrackInfo) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
}
extension VideoEditor.VideoEditorAssetTrackInfo {
  final public func isTimeInGlobalTimeRange(_ time: CoreMedia.CMTime) -> Swift.Bool
}
public protocol SDKVideoCompositionInstructionDataSource : AnyObject {
  func getEffects(at time: CoreMedia.CMTime) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
  func getEffectsBefore(time: CoreMedia.CMTime) -> [any VideoEditor.EditorCompositionEditableEffectProtocol]
}
@objc @_inheritsConvenienceInitializers public class VideoImageEffectDrawersFactory : ObjectiveC.NSObject {
  public static let normalDrawer: any VideoEditor.VideoImageEffectDrawable
  public static func drawer(for image: CoreGraphics.CGImage) -> any VideoEditor.VideoImageEffectDrawable
  @objc override dynamic public init()
  @objc deinit
}
public struct MetalBlendingParameters {
  public init(isBlendingEnabled: Swift.Bool, sourceRGBBlendFactor: Metal.MTLBlendFactor, destinationRGBBlendFactor: Metal.MTLBlendFactor, sourceAlphaBlendFactor: Metal.MTLBlendFactor, destinationAlphaBlendFactor: Metal.MTLBlendFactor)
}
public class MetalHelper {
  final public let commandQueue: any Metal.MTLCommandQueue
  final public let depthStencilState: any Metal.MTLDepthStencilState
  public init(libraryBundle: Foundation.Bundle)
  public func rgbaTextureForPixelBuffer(_ pixelBuffer: CoreVideo.CVPixelBuffer) -> (any Metal.MTLTexture)?
  public func createMonochromeTexture(textureData: Swift.UnsafeMutablePointer<Swift.UInt8>, width: Swift.Int, height: Swift.Int) -> any Metal.MTLTexture
  public func createRenderPipeline(vertexFunctionName: Swift.String, fragmentFunctionName: Swift.String, pixelFormat: Metal.MTLPixelFormat = .bgra8Unorm, depthPixelFormat: Metal.MTLPixelFormat? = nil, blendParameters: VideoEditor.MetalBlendingParameters? = nil, bundle: Foundation.Bundle = Bundle.main, label: Swift.String? = nil) -> (any Metal.MTLRenderPipelineState)?
  public func setupRenderPassDescriptor(destinationTexture: any Metal.MTLTexture, useBufferFetch: Swift.Bool = false) -> Metal.MTLRenderPassDescriptor
  public func setupRenderPassDescriptor(destinationTexture: any Metal.MTLTexture, depth: any Metal.MTLTexture) -> Metal.MTLRenderPassDescriptor
  public func makeBuffer<T>(array: [T]) -> any Metal.MTLBuffer
  public func makeBuffer(bytes pointer: Swift.UnsafeRawPointer, length: Swift.Int, options: Metal.MTLResourceOptions = []) -> any Metal.MTLBuffer
  public func makeTexture(descriptor: Metal.MTLTextureDescriptor) -> any Metal.MTLTexture
  public func makeDefaultUVBuffer() -> any Metal.MTLBuffer
  public func makeDefaultVertexBuffer() -> any Metal.MTLBuffer
  @objc deinit
}
extension Metal.MTLBuffer {
  public func replaceData<T>(with newData: [T])
}
@objc public class ImageConfiguration : ObjectiveC.NSObject, BanubaUtilities.ImageConfigurationProtocol {
  public var imageName: Swift.String
  @objc public var tintColor: UIKit.UIColor?
  @objc public var image: UIKit.UIImage? {
    @objc get
  }
  public init(imageName: Swift.String, tintColor: UIKit.UIColor? = nil)
  public init(image: UIKit.UIImage, tintColor: UIKit.UIColor? = nil)
  @objc deinit
}
public struct WatermarkConfiguration {
  public var watermark: VideoEditor.ImageConfiguration
  public var size: CoreFoundation.CGSize
  public var sharedOffset: CoreFoundation.CGFloat
  public var position: VideoEditor.WatermarkConfiguration.WatermarkPosition
  public var id: Swift.UInt?
  public enum WatermarkPosition {
    case leftTop
    case leftBottom
    case rightTop
    case rightBottom
    public static func == (a: VideoEditor.WatermarkConfiguration.WatermarkPosition, b: VideoEditor.WatermarkConfiguration.WatermarkPosition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var expiredWatermarkId: Swift.UInt
  public static var expiredWatermark: VideoEditor.WatermarkConfiguration {
    get
  }
  public init(watermark: VideoEditor.ImageConfiguration, size: CoreFoundation.CGSize, sharedOffset: CoreFoundation.CGFloat, position: VideoEditor.WatermarkConfiguration.WatermarkPosition, id: Swift.UInt? = nil)
}
public protocol VideoSequenceServicing {
  var videoSequences: [VideoEditor.VideoSequence] { get }
  var currentSequence: VideoEditor.VideoSequence? { get }
  func setupCurrentSequence(_ videoSequence: VideoEditor.VideoSequence?)
  @discardableResult
  func startNewSequence() -> VideoEditor.VideoSequence
  func cancelCurrentSequence()
  func duplicateSequence(_ videoSequence: VideoEditor.VideoSequence) -> VideoEditor.VideoSequence
  func replaceSequence(_ videoSequenceToReplace: VideoEditor.VideoSequence, withSequence videoSequence: VideoEditor.VideoSequence)
  @discardableResult
  func removeSequence(_ videoSequence: VideoEditor.VideoSequence) -> Swift.Bool
  func removeAllSequences()
}
public class VideoSequenceService {
  public var videoSequences: [VideoEditor.VideoSequence] {
    get
  }
  public var currentSequence: VideoEditor.VideoSequence?
  public init()
  @objc deinit
}
extension VideoEditor.VideoSequenceService : VideoEditor.VideoSequenceServicing {
  public func setupCurrentSequence(_ videoSequence: VideoEditor.VideoSequence?)
  @discardableResult
  public func startNewSequence() -> VideoEditor.VideoSequence
  public func cancelCurrentSequence()
  @discardableResult
  public func removeSequence(_ videoSequence: VideoEditor.VideoSequence) -> Swift.Bool
  @discardableResult
  public func duplicateSequence(_ videoSequence: VideoEditor.VideoSequence) -> VideoEditor.VideoSequence
  public func replaceSequence(_ videoSequenceToReplace: VideoEditor.VideoSequence, withSequence videoSequence: VideoEditor.VideoSequence)
  public func removeAllSequences()
}
extension VideoEditor.EditorEffectType : Swift.Equatable {}
extension VideoEditor.EditorEffectType : Swift.Hashable {}
extension VideoEditor.EditorEffectType : Swift.RawRepresentable {}
extension VideoEditor.ContentLocationType : Swift.Equatable {}
extension VideoEditor.ContentLocationType : Swift.Hashable {}
extension VideoEditor.AssetCrop : Swift.Equatable {}
extension VideoEditor.AssetCrop : Swift.Hashable {}
extension VideoEditor.AssetCrop : Swift.RawRepresentable {}
extension VideoEditor.AssetRotation : Swift.Equatable {}
extension VideoEditor.AssetRotation : Swift.Hashable {}
extension VideoEditor.AssetRotation : Swift.RawRepresentable {}
extension VideoEditor.EffectSpeed : Swift.Equatable {}
extension VideoEditor.EffectSpeed : Swift.Hashable {}
extension VideoEditor.EffectSpeed : Swift.RawRepresentable {}
extension VideoEditor.VideoEditorAssetTrackInfo.CodingKeys : Swift.Equatable {}
extension VideoEditor.VideoEditorAssetTrackInfo.CodingKeys : Swift.Hashable {}
extension VideoEditor.VideoEditorAssetTrackInfo.CodingKeys : Swift.RawRepresentable {}
extension VideoEditor.WatermarkConfiguration.WatermarkPosition : Swift.Equatable {}
extension VideoEditor.WatermarkConfiguration.WatermarkPosition : Swift.Hashable {}
